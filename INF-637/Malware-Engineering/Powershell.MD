# Pwrshell  revision and other advanced techniques 


## Topics : 


## 1. Powershell remote access using SSH : 
    can be done with the help of WinRM  (windows remote management ) and openSSL protocosl , they are gneerally enables in the windows server edition . it follows ports 5985/5986 ports . although it insures isolated instances on the remoting connections , in order to allow all connections on the public network , there needs to be changes in the waf settings , which in turn generates the attack vectors . 

## 2. Deep dives on the PShell primitives : 
[credits](PowershellExplained.com)

2.1 understanding the usees of arrays :
    PS > $data = @() ---> $data.count . also we cna use the comma seperated values in order to get the array representation.

    indexing techniques :
        - $data[i,i+1 or i...i+n or i ... $data.count or $data.getUpperBound]

    implementation of pipeline objects: 

    $data | ForEach-Object ({"Item [$PSItem]"})

    $data | Where-Object {$_.FirstName -eq 'Kevin'}

    $data | When FirstName -eq value

    #implementing regex pattern :

    $data = @('red' , 'green' , 'blue')
    $pattern = "^({0})$" - f ($data -join '|')
    'green' -match $pattern

    # the other ways to include the pattern regex matching : Select-String , -Match , $matches 

    if ($array -eq $null)
    {
        'Array is $null'

    }


    $array = @('one' , $null , 'three')
    if (not ($results -ne 'three'))
    {
        'all the information'
    }    

    ## Adding to arrays  and += 

    $array = N...N+1 | ForEach-Object {
        "Ps-SQL-$PSItem"
    } 

    $array = foreach ($node in (1..5))
    {
        "ATX-SQL-$PSItem"
    }

    ## in generally , all of the information is stored in the [PSObject[]]
    but in case to maintain the strong typed arrays in order to maintain the consistency.

    [int[]] $numbers = 1,2,3
    $mylist = [System.Collections.Generic.List[string]]::new()

    then we have the 

## for miscellaneous powershell commands :
1. using -What-If anf -Confirm in roder to get the  information about the possible state changes after the execution of the command , whereas -Confirm will allow you to  ask the user  finally for an estructive command. 


function Test-ShouldProcess {
    [CmdletBinding(SupportsShouldProcess)]
    param()
    Remove-Item . \myfile1.txt -WhatIf:$WhatIf
    }

$PSCmdlet.ShouldProcess

Test-ShouldProcess -Whatif

Test-ShouldProcess -Verbose 


function Test-ShouldProcess {
    [Cmdlet]

}

foreach($item in $array)
{   Write-Output $item
}

Write-Output $array[3]
